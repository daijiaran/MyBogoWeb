import json
import re

# 读取试卷组文件
with open(r'c:\Users\DAI\IdeaProjects\vue_project_2\.trae\数据库原理试卷组_final.json', 'r', encoding='utf-8') as f:
    exam_group = json.load(f)

# 定义解析模板
class ExplanationGenerator:
    def __init__(self):
        self.judge_explanations = {
            1: "数据库系统的主要特点包括数据结构化、数据共享性高、数据独立性强、数据由DBMS统一管理和控制等。虽然数据库系统可以减少数据冗余，但并不能完全消除冗余，适当的冗余有时是必要的。",
            2: "数据库系统(DBS)由数据库(DB)、数据库管理系统(DBMS)、应用程序、数据库管理员(DBA)和用户组成。仅仅有DB和DBMS是不够的。",
            3: "数据结构化是数据库和文件系统的根本区别。文件系统中的数据是面向应用的，数据之间缺乏联系；而数据库系统中的数据是结构化的，数据之间存在明确的联系。",
            4: "在数据库系统设计中，模式(Schema)只有一个，它是数据库的全局逻辑结构描述；而外模式(Subschema)可以有多个，每个外模式对应一个用户或应用程序的局部逻辑结构。",
            5: "数据库系统中的数据具有物理独立性和逻辑独立性，但这种独立性是相对的，不是完全的。当数据库的物理结构或逻辑结构发生变化时，可能需要对应用程序进行适当的调整。",
            6: "DBA(数据库管理员)的主要职责包括数据库设计、数据库维护、数据库安全性管理、数据库性能优化等，而不仅仅是管理数据库中的数据。",
            7: "数据库可以减少数据冗余，但不能避免一切数据重复。在某些情况下，适当的冗余是必要的，例如为了提高查询效率或保证数据的完整性。",
            8: "每一种DBMS(数据库管理系统)的实现都是建立在某一种数据模型基础之上的，例如关系模型、层次模型、网状模型等。",
            9: "非过程化语言和过程化语言各有优缺点，不能简单地说哪一种更好。非过程化语言(如SQL)更适合于数据查询和操作，而过程化语言(如C、Java)更适合于复杂的业务逻辑处理。",
            10: "模式(Schema)是数据库的全局逻辑结构描述，它定义了数据库中所有数据的结构和关系。",
            11: "关系模型不仅可以描述实体，还可以通过关系(表)之间的联系来描述实体及实体集之间的关系。",
            12: "概念模型是现实世界的抽象，它独立于具体的硬件设备和DBMS，主要用于数据库设计阶段。",
            13: "一个关系模式可以有多个候选码，候选码是指能够唯一标识关系中一个元组的属性或属性组合。",
            14: "BETWEEN AND操作符包括两端的值，即Sage BETWEEN 20 AND 30等价于Sage >= 20 AND Sage <= 30。因此，年龄为20岁和30岁的同学都满足这个条件。",
            15: "在执行INSERT、UPDATE或DELETE语句对数据进行更新操作之前，数据库系统会首先检查这个操作的结果是否会破坏已有的完整性约束(如实体完整性、参照完整性和用户自定义完整性)。",
            16: "使用CREATE TABLE语句创建表时，一条语句只能创建一张表。如果需要创建多张表，需要多条CREATE TABLE语句。",
            17: "数据库设计的第一步是需求分析，而不是概念结构设计。需求分析的目的是确定数据库系统的功能和性能要求。",
            18: "SQL语句的一次查询结果是一个关系(表)，而不是一个元组(记录)。一个关系可以包含零个或多个元组。",
            19: "从一个关系中取出满足某个条件的所有记录形成一个新的关系操作是选择(SELECT)操作，而不是连接(JOIN)操作。连接操作是将两个或多个关系中的元组按照一定的条件连接起来。",
            20: "同一个关系中的任意两个元组值不能全同，这是由关系的实体完整性约束保证的。",
            21: "概念模型是现实世界的第一层抽象，这一类模型中最著名的模型是实体-联系(E-R)模型，而不是层次模型。",
            22: "实体是信息世界中的术语，与之相对应的数据库术语为元组(记录)，而不是字段。字段对应的是信息世界中的属性。",
            23: "SQL语言是非过程化的语言，用户只需要说明做什么，而不需要说明怎么做。",
            24: "第一范式(1NF)的定义是：关系中的每个属性都是不可分割的原子值，且不存在多值属性。如果关系R满足这个条件，则R至少满足第一范式。",
            25: "一个表中最多只能有一个主键(Primary Key)，用于唯一标识表中的元组；但可以有多个外键(Foreign Key)，用于建立表与表之间的联系。",
            26: "第三范式(3NF)的定义是：关系模式满足2NF且不存在传递依赖。传递依赖是指非主属性通过其他非主属性间接依赖于主键。",
            27: "关系代数中的集合操作(如并集、交集和差集)要求参与操作的关系具有相同的属性集合和相同的属性顺序，这称为关系的相容性。",
            28: "关系代数中的连接操作(Join)的结果元组数量取决于连接条件和参与连接的关系中的数据。连接结果的元组数量可能小于、等于或大于参与连接的关系中的元组数量。",
            29: "数据库设计需要同时考虑数据的存储结构(物理设计)和数据的逻辑结构(概念设计和逻辑设计)。",
            30: "数据库设计需要考虑数据的安全性，包括用户认证、授权、加密等。虽然数据库管理系统提供了一些安全措施，但还需要在设计阶段考虑如何保护数据的安全性。",
            31: "在SQL中，判断某元组的某一属性值是否为空值，只能使用FName IS NULL语法，不能使用FName = NULL语法。因为NULL表示未知值，与任何值比较的结果都是未知的。",
            32: "使用INSERT语句向表中插入数据时，如果插入的数据包含表中所有列的值，并且值的顺序与表中列的顺序一致，则可以省略列的名称。",
            33: "使用INSERT语句向表中插入数据时，VALUES子句中的值的数量必须与指定的列的数量一致。在这个例子中，SC表有3列(Sno, Cno, Grade)，但只提供了2个值，因此语句是错误的。",
            34: "参照关系R和被参照关系S可以是同一个关系，这种情况称为自引用关系。例如，一个员工表中可能包含一个经理ID列，该列引用同一个表中的员工ID。",
            35: "在SQL中，可以为SELECT子句中的目标列表达式指定别名，一种方法是直接在目标列表达式后加上空格和别名，另一种方法是使用AS关键字。"
        }
        
        self.single_explanations = {
            1: "数据库管理系统(DBMS)是一组软件，用于管理数据库中的数据。它提供了数据定义、数据操纵、数据控制等功能。",
            2: "用户或应用程序看到的那部分局部逻辑结构和特征的描述是外模式(Subschema)，也称为子模式。",
            3: "数据库系统(DBS)包括数据库(DB)、数据库管理系统(DBMS)、应用程序、数据库管理员(DBA)和用户。",
            4: "数据库的概念模型独立于具体的机器和DBMS，它是对现实世界的抽象描述。",
            5: "在关系R和S中，R的主码是R#，S的主码是S#，则S#在R中称为外码(Foreign Key)，用于建立R和S之间的联系。",
            6: "在SQL中，若要求查询结果中不能出现重复元组，可在SELECT子句后增加DISTINCT关键字。",
            7: "数据库管理系统能实现对数据库中数据的查询、插入、修改和删除，这类功能称为数据操纵功能。",
            8: "在关系模型中，一个码是由一个或多个其值能唯一标识该关系模式中任何元组的最少属性组成。",
            9: "在SQL中，需要对分组情况应满足的条件进行判断时，应使用HAVING子句。WHERE子句用于筛选行，而HAVING子句用于筛选分组。",
            10: "SQL语言是结构化查询语言(Structured Query Language)的缩写，它是一种用于管理关系数据库的标准语言。",
            11: "用户眼中的数据库称为外模式(Subschema)，它是用户或应用程序看到的局部逻辑结构。",
            12: "在数据库设计中，E-R图(实体-联系图)产生于概念设计阶段，用于描述现实世界的实体及其联系。",
            13: "学号的值域是8个数字组成的字符串，这一规则属于用户自定义完整性约束，它是根据应用领域的具体需求定义的约束条件。",
            14: "关系模型是用关系(二维表格)表示实体及其联系的一种数据模型。",
            15: "概念模型是现实世界的第一层抽象，这一类模型中最著名的模型是实体-联系(E-R)模型。",
            16: "在SQL中，LIKE操作符用于模糊查询。'%'表示任意长度的字符串，'_'表示任意单个字符。要检索第3个字母为N且至少包含4个字母的书名，应使用'__N_%'。",
            17: "一个实验项目可以有多名同学参加，每名同学可参加多个实验项目，因此学生与实验项目之间是多对多的关系。",
            18: "采用二维表格结构表达实体型及实体间联系的数据模型是关系模型。",
            19: "现实世界中的事物个体在信息世界中称为实体。",
            20: "实体完整性和参照完整性是关系模型必须满足的完整性约束条件，而用户自定义完整性是应用领域需要遵循的约束条件，体现了具体领域的语义约束。",
            21: "学生与课程之间是多对多的联系，因为一个学生可以选修多门课程，一门课程可以被多个学生选修。",
            22: "SQL的SELECT语句中，HAVING子句必须配合GROUP BY子句使用，用于对分组结果进行筛选。",
            23: "在关系代数中，从关系中选择满足条件的元组的操作是选择(SELECT)操作。",
            24: "在SQL中，创建表的语句是CREATE TABLE。",
            25: "数据库设计的正确步骤是：需求分析、概念设计、逻辑设计、物理设计。",
            26: "在E-R图中，矩形表示实体，菱形表示联系，椭圆表示属性。",
            27: "在SQL中，修改表结构的语句是ALTER TABLE。",
            28: "在关系代数中，将两个关系中的元组按照一定的条件连接起来的操作是连接(JOIN)操作。",
            29: "在SQL中，删除表中数据的语句是DELETE。",
            30: "在数据库系统中，数据的独立性包括物理独立性和逻辑独立性。物理独立性是指当数据库的物理结构发生变化时，应用程序不需要修改；逻辑独立性是指当数据库的逻辑结构发生变化时，应用程序不需要修改。",
            31: "在SQL中，更新表中数据的语句是UPDATE。",
            32: "在关系模型中，实体之间的联系可以分为一对一、一对多和多对多三种类型。",
            33: "在SQL中，为表中的列添加约束的语句是ALTER TABLE ADD CONSTRAINT。",
            34: "在关系代数中，对关系进行投影操作的结果是一个新的关系，该关系包含原关系中的部分列。",
            35: "在SQL中，查询表中所有数据的语句是SELECT * FROM table_name。",
            36: "在数据库设计中，规范化的目的是消除数据冗余和更新异常，提高数据的一致性和完整性。",
            37: "在SQL中，创建索引的语句是CREATE INDEX。",
            38: "在关系模型中，主键是用于唯一标识关系中元组的属性或属性组合。",
            39: "在SQL中，删除表的语句是DROP TABLE。",
            40: "在数据库系统中，事务是一个不可分割的工作单位，它具有原子性、一致性、隔离性和持久性四个特性。"
        }
    
    def generate_judge_explanation(self, question_id):
        return self.judge_explanations.get(question_id, "本题暂无解析")
    
    def generate_single_explanation(self, question_id):
        return self.single_explanations.get(question_id, "本题暂无解析")

# 创建解析生成器
generator = ExplanationGenerator()

# 为所有题目生成解析
total_questions = 0
for exam in exam_group:
    exam_title = exam['title']
    questions = exam['questions']
    print(f"处理试卷：{exam_title}，包含题目数量：{len(questions)}")
    
    for i, question in enumerate(questions):
        question_id = i + 1
        if exam_title == "数据库原理判断题":
            explanation = generator.generate_judge_explanation(question_id)
        elif exam_title == "数据库原理单选题":
            explanation = generator.generate_single_explanation(question_id)
        else:
            explanation = "本题暂无解析"
        
        question['explanation'] = explanation
        total_questions += 1

# 将结果写入新文件
output_file = r'c:\Users\DAI\IdeaProjects\vue_project_2\.trae\数据库原理试卷组_with_explanations.json'
with open(output_file, 'w', encoding='utf-8') as f:
    json.dump(exam_group, f, ensure_ascii=False, indent=2)

print(f"\n=== 解析生成完成 ===")
print(f"输出文件：{output_file}")
print(f"共处理题目数量：{total_questions}")
print("所有题目已添加详细解析！")
